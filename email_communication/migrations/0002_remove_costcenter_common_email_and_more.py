# Generated by Django 5.2.4 on 2025-11-06 14:46
# Modified to handle existing Oracle objects gracefully

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


def check_table_exists(cursor, table_name):
    """Check if a table exists in Oracle database"""
    try:
        cursor.execute("""
            SELECT COUNT(*) 
            FROM user_tables 
            WHERE table_name = UPPER(%s)
        """, [table_name])
        return cursor.fetchone()[0] > 0
    except Exception:
        return False


def check_column_exists(cursor, table_name, column_name):
    """Check if a column exists in a table in Oracle database"""
    try:
        cursor.execute("""
            SELECT COUNT(*) 
            FROM user_tab_columns 
            WHERE table_name = UPPER(%s) AND column_name = UPPER(%s)
        """, [table_name, column_name])
        return cursor.fetchone()[0] > 0
    except Exception:
        return False


class SafeCreateModel(migrations.CreateModel):
    """
    Custom CreateModel that handles existing tables in Oracle.
    If table exists, it will try to add any missing columns from the model definition.
    """
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        if schema_editor.connection.vendor == 'oracle':
            model = to_state.apps.get_model(app_label, self.name)
            with schema_editor.connection.cursor() as cursor:
                if not check_table_exists(cursor, model._meta.db_table):
                    # Table doesn't exist - create it normally
                    super().database_forwards(app_label, schema_editor, from_state, to_state)
                else:
                    # Table exists - check and add missing columns
                    print(f"Table {model._meta.db_table} already exists, checking for missing columns...")
                    for field in model._meta.local_fields:
                        column_name = field.column
                        if not check_column_exists(cursor, model._meta.db_table, column_name):
                            print(f"  Adding missing column: {column_name}")
                            try:
                                schema_editor.add_field(model, field)
                            except Exception as e:
                                print(f"  Warning: Could not add column {column_name}: {e}")
                        else:
                            print(f"  Column {column_name} already exists")
        else:
            super().database_forwards(app_label, schema_editor, from_state, to_state)


class SafeRemoveField(migrations.RemoveField):
    """Custom RemoveField that skips if column doesn't exist in Oracle"""
    
    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        if schema_editor.connection.vendor == 'oracle':
            from_model = from_state.apps.get_model(app_label, self.model_name)
            with schema_editor.connection.cursor() as cursor:
                if check_column_exists(cursor, from_model._meta.db_table, self.name):
                    super().database_forwards(app_label, schema_editor, from_state, to_state)
        else:
            super().database_forwards(app_label, schema_editor, from_state, to_state)


class Migration(migrations.Migration):

    dependencies = [
        ('email_communication', '0001_initial'),
    ]

    operations = [
        SafeRemoveField(
            model_name='costcenter',
            name='common_email',
        ),
        SafeRemoveField(
            model_name='costcenter',
            name='manager_email',
        ),
        SafeRemoveField(
            model_name='costcenter',
            name='users',
        ),
        SafeCreateModel(
            name='CostCenterEmail',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('email', models.EmailField(max_length=255, validators=[django.core.validators.EmailValidator()], verbose_name='Email Address')),
                ('email_hash', models.CharField(db_index=True, editable=False, help_text='SHA256 hash for database-portable queries', max_length=64)),
                ('email_type', models.CharField(choices=[('recipient', 'Recipient (TO)'), ('cc', 'CC (Carbon Copy)')], db_index=True, help_text='Type of email: recipient (TO) or cc', max_length=20, verbose_name='Email Type')),
                ('display_name', models.CharField(blank=True, help_text='Optional display name for the email', max_length=255, null=True, verbose_name='Display Name')),
                ('is_active', models.BooleanField(db_index=True, default=True, verbose_name='Is Active')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Created At')),
                ('cost_center', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='emails', to='email_communication.costcenter', verbose_name='Cost Center')),
            ],
            options={
                'verbose_name': 'Cost Center Email',
                'verbose_name_plural': 'Cost Center Emails',
                'db_table': 'email_costcenter_email',
                'ordering': ['email_type', 'email'],
                'indexes': [models.Index(fields=['email_hash'], name='idx_cc_email_hash'), models.Index(fields=['email_type'], name='idx_cc_email_type'), models.Index(fields=['cost_center', 'email_type'], name='idx_cc_emailtype')],
                'unique_together': {('cost_center', 'email', 'email_type')},
            },
        ),
    ]
